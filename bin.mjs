#!/usr/bin/env node
import Le from"@electron/asar";import{copyFileSync as Ge,cpSync as je,existsSync as O,mkdirSync as ae,readFileSync as X,rmSync as le,writeFileSync as Ee}from"fs";import{cwd as Ue}from"process";import z from"esbuild";import d from"path";import Je from"update-notifier";import We from"yargs";import{hideBin as Ve}from"yargs/helpers";import W from"chalk";import Oe from"ws";import{existsSync as pe,readFileSync as fe,writeFileSync as ge}from"fs";import B from"path";import k from"prompts";import C from"semver";import j from"chalk";import{execSync as he}from"child_process";import{existsSync as _,readdirSync as Y}from"fs";import A from"path";import me from"prompts";var h=_(A.join(process.cwd(),"plugins"))||_(A.join(process.cwd(),"themes"));function I(e){if(!_(A.join(m,e)))return[];let t=Y(A.join(m,e),{withFileTypes:!0});return t.filter(n=>n.isDirectory()),t.map(n=>n.name)}async function N(e){if(e!=="all"){let t=I(e),{addon:n}=await me({type:"select",name:"addon",message:"Select an addon",choices:t.map(i=>({title:i,value:{type:e,name:i}}))},{onCancel:$});return n}else{let t=[],n=[];_(A.join(m,"plugins"))&&Y(A.join(m,"plugins"),{withFileTypes:!0}).forEach(o=>{o.isDirectory()&&t.push(o.name)}),_(A.join(m,"themes"))&&Y(A.join(m,"themes"),{withFileTypes:!0}).forEach(o=>{o.isDirectory()&&n.push(o.name)});let{addon:i}=await me({type:"select",name:"addon",message:"Select an addon",choices:[...t.map(o=>({title:`${o} (plugin)`,value:{type:"plugins",name:o}})),...n.map(o=>({title:`${o} (theme)`,value:{type:"themes",name:o}}))]},{onCancel:$});return i}}async function L(e,t=!1){let{doContinue:n}=await k({type:"confirm",name:"doContinue",message:j.yellow(e),initial:t},{onCancel:$});n||(console.log(j.red("Aborting")),process.exit(0))}function S(e,t=!0){try{return he(e,{encoding:"utf8",cwd:ye()})}catch(n){if(!t)return n.stdout;console.error(n.message),process.exit(1)}}function $(){console.log(j.red("Aborting")),process.exit(128)}var G;function ye(){if(G)return G;try{return G=he("git rev-parse --show-toplevel",{encoding:"utf8",cwd:process.cwd()}).trim(),G}catch(e){e.message.includes("not a git repository")&&(console.log(j.red("You must run this command from within a git repository")),process.exit(1)),console.error(`Command failed with exit code ${e.status}: ${e.message}`),process.exit(1)}throw new Error("Unreachable")}async function be(){let e=ye();!S("git status --porcelain").trim()||await L("Working directory is not clean. Continue?");let i=h?await N("all"):null,o=i?B.resolve(e,i.type,i.name,"manifest.json"):B.resolve(e,"manifest.json");pe(o)||(console.log(j.red("manifest.json not found")),process.exit(1));let p=fe(o,"utf8"),s;try{s=JSON.parse(p)}catch{console.log(j.red("manifest.json is not valid JSON")),process.exit(1)}let a=i?null:B.resolve(e,"package.json");!h&&!pe(a)&&(console.log(j.red("package.json not found")),process.exit(1));let g=a?fe(a,"utf8"):null,c;try{c=a?JSON.parse(g):null}catch{console.log(j.red("package.json is not valid JSON")),process.exit(1)}let{version:f}=s,r,y=!!C.valid(f);if(y){let b=C.inc(f,"patch"),T=C.inc(f,"minor"),ue=C.inc(f,"major");({nextVersion:r}=await k({type:"select",name:"nextVersion",message:"Version",choices:[{title:`Patch: v${b}`,value:b},{title:`Minor: v${T}`,value:T},{title:`Major: v${ue}`,value:ue},{title:"Custom",value:null}]},{onCancel:$}))}r||({nextVersion:r}=await k({type:"text",name:"nextVersion",message:y?"Custom Version":"Version",validate:b=>b.trim()?!0:"Version is required"},{onCancel:$})),r=r.trim();let P=!!C.valid(r);if(y)if(P){C.lte(r,f)&&await L(`Version ${r} is not greater than ${f}. Continue?`);let b=C.clean(r);if(b!==r){let{clean:T}=await k({type:"confirm",name:"clean",message:`Convert ${r} to cleaned version ${b}?`,initial:!0});T&&(r=b)}}else await L(`Version ${r} is not a valid semver. Continue?`);s.version=r,c&&(c.version=r),ge(o,`${JSON.stringify(s,null,2)}
`),c&&ge(a,`${JSON.stringify(c,null,2)}
`),S(h?`git add ${B.join(i.type,i.name,"manifest.json")}`:"git add manifest.json package.json");let{message:v}=await k({type:"text",name:"message",message:"Commit message",initial:h?`[${s.name}] Release v${r}`:`Release v${r}`,validate:b=>b.trim()?!0:"Commit message is required"},{onCancel:$}),x=S("git tag --list").split(`
`).filter(Boolean),{tagName:w}=await k({type:"text",name:"tagName",message:"Tag name",initial:h?`v${r}-${s.name.replace(" ","_")}`:`v${r}`,validate:b=>b.trim()?x.includes(b)?`Tag ${b} already exists`:!0:"Tag name is required"},{onCancel:$}),u=!!S("git config --get user.signingkey",!1).trim(),D=S("git config --get commit.gpgsign",!1).trim()==="true",Me=S("git config --get tag.gpgsign",!1).trim()==="true",K=!1;u&&(!D||!Me)&&({sign:K}=await k({type:"confirm",name:"sign",message:"Sign commit and tag?",initial:!0})),S(`git commit${K?" -S":""} -m "${v}"`),S(`git tag${K?" -s":""} -a -m "${v}" "${w}"`),await L("Push changes to remote?",!0),S("git push"),S("git push --tags")}import{execSync as _e}from"child_process";import{chownSync as ee,existsSync as J,mkdirSync as we,statSync as Re,writeFileSync as Fe}from"fs";import Q,{join as E}from"path";import R from"chalk";var U="replugged",Te=()=>{let e=process.env.SUDO_USER||process.env.DOAS_USER,t=process.env.HOME;switch(process.platform){case"win32":return E(process.env.APPDATA||"",U);case"darwin":return E(t||"","Library","Application Support",U);default:if(process.env.XDG_CONFIG_HOME)return E(process.env.XDG_CONFIG_HOME,U);if(e)try{let n=_e(`getent passwd ${e}`,{stdio:[null,null,"ignore"]}).toString("utf-8").split(":")[5];n&&J(n)?t=n:(console.error(new Error(`Passwd entry for "${e}" contains an invalid home directory.`)),process.exit(1))}catch(n){console.error("Could not find passwd entry of sudo/doas user",n),process.exit(1)}return E(t||"",".config",U)}},M=Te();J(M)||we(M,{recursive:!0});var ve=["plugins","themes","settings","quickcss","react-devtools"],Ie=Object.fromEntries(ve.map(e=>{let t=E(M,e);return J(t)||we(t),[e,t]})),{uid:te,gid:ne}=Re(E(M,"..")),Se=process.platform==="linux";Se&&(ee(M,te,ne),ve.forEach(e=>ee(E(M,e),te,ne)));var Z=E(Ie.quickcss,"main.css");J(Z)||(Fe(Z,""),Se&&ee(Z,te,ne));var Be=e=>{if(e===0)return"0b";let t=1024,n=1,i=["b","kb","mb","gb"],o=Math.floor(Math.log(e)/Math.log(t));return`${parseFloat((e/Math.pow(t,o)).toFixed(n))}${i[o]}`},oe={name:"logBuild",setup:e=>{let t;e.onStart(()=>{t=Date.now()}),e.onEnd(n=>{var g;let i=Date.now()-t,o=((g=n.metafile)==null?void 0:g.outputs)||{},p=Object.entries(o).sort(([c],[f])=>{let r=c.endsWith(".map"),y=f.endsWith(".map");return r&&!y?1:!r&&y?-1:0}).map(([c,{bytes:f}])=>{let{sep:r}=Q,y=Q.dirname(c),P=Q.basename(c),v=[y,r,R.bold(P)].join(""),x=Be(f),w=f>Math.pow(1024,2)&&!c.endsWith(".map"),u=w?R.yellow(x):R.cyan(x),D=w?R.yellow(" \u26A0\uFE0F"):"";return{name:v,size:u,suffix:D}}),s=Math.max(...p.map(({name:c})=>c.length)),a=Math.max(...p.map(({size:c})=>c.length));console.log(""),p.forEach(({name:c,size:f,suffix:r})=>{console.log(`  ${c.padEnd(s+1)} ${f.padStart(a)}${r}`)}),console.log(""),console.log(`\u26A1 ${R.green(`Done in ${i.toLocaleString()}ms`)}`)})}};import{sassPlugin as He}from"esbuild-sass-plugin";import{fileURLToPath as qe}from"url";var m=process.cwd(),ze=d.dirname(qe(import.meta.url)),Xe=JSON.parse(X(d.resolve(ze,"package.json"),"utf-8")),ce=new Promise(e=>e(t=>t));O("./esbuild.extra.mjs")&&(ce=new Promise(e=>{import(d.join(Ue(),"esbuild.extra.mjs")).then(t=>{e(t.default)})}));var Ke=`Update available ${W.dim("{currentVersion}")}${W.reset(" \u2192 ")}${W.green("{latestVersion}")} 
Run ${W.cyan("pnpm i -D replugged")} to update`,Ye=Je({pkg:Xe,shouldNotifyInNpmScript:!0});function Pe(){Ye.notify({message:Ke})}var Qe=6463,Ze=6472;function De(){return Math.random().toString(16).slice(2)}var l,xe=!1,F;function et(e){return l=new Oe(`ws://127.0.0.1:${e}/?v=1&client_id=REPLUGGED-${De()}`),new Promise((t,n)=>{let i=!1;l==null||l.on("message",o=>{i||JSON.parse(o.toString()).evt!=="READY"||(i=!0,t(l))}),l==null||l.on("error",()=>{i||(i=!0,n(new Error("WebSocket error")))}),l==null||l.on("close",()=>{l=void 0,!i&&(i=!0,n(new Error("WebSocket closed")))})})}async function tt(){if(l&&l.readyState===Oe.OPEN)return l;if(xe)return null;if(F)return await F;F=(async()=>{for(let t=Qe;t<=Ze;t++)try{return l=await et(t),l}catch{}})();let e=await F;if(F=void 0,e)return e;console.error("Could not connect to Discord websocket"),xe=!0}var se=!1,ie=!1;async function de(e){let t=await tt();if(!t)return;if(se){ie=!0;return}let n=De();t.send(JSON.stringify({cmd:"REPLUGGED_ADDON_WATCHER",args:{id:e},nonce:n})),se=!0,await new Promise(i=>{let o=async p=>{let s=JSON.parse(p.toString());if(s.nonce===n){if(t.off("message",o),se=!1,ie){ie=!1,i(await de(e));return}if(s.data.success)console.log("Reloaded addon"),i(void 0);else{let a=s.data.error,g="Unknown error";switch(a){case"ADDON_NOT_FOUND":g="Addon not found";break;case"ADDON_DISABLED":g="Addon disabled";break;case"RELOAD_FAILED":g="Reload failed";break}console.error(`Failed to reload addon: ${g}`),i(void 0)}}};t.on("message",o)})}function Ae(e,t){I(t).forEach(i=>re(e,i,t))}async function re(e,t,n){let i=t?d.join(m,n,t,"manifest.json"):d.join(m,"manifest.json"),o=JSON.parse(X(i,"utf-8")),p=t?`dist/${o.id}`:"dist";O(p)&&le(p,{recursive:!0}),await e({watch:!1,noInstall:!0,production:!0,addon:t});let s=`bundle/${o.id}`;O("bundle")||ae("bundle"),Le.createPackage(p,`${s}.asar`),Ge(`${p}/manifest.json`,`${s}.json`),console.log(`Bundled ${o.name}`)}async function Ne(e,t){await Promise.all(e.map(async n=>{t?await n.watch():(await n.rebuild().catch(()=>{}),n.dispose())}))}var V="replugged",Ce=(()=>{switch(process.platform){case"win32":return d.join(process.env.APPDATA||"",V);case"darwin":return d.join(process.env.HOME||"","Library","Application Support",V);default:return process.env.XDG_CONFIG_HOME?d.join(process.env.XDG_CONFIG_HOME,V):d.join(process.env.HOME||"",".config",V)}})(),ke="91";function $e(e,t,n){I(n).forEach(o=>{e({...t,addon:o})})}async function H({watch:e,noInstall:t,production:n,noReload:i,addon:o}){let p=o?d.join(m,"plugins",o,"manifest.json"):d.join(m,"manifest.json"),s=JSON.parse(X(p.toString(),"utf-8")),a=o?`dist/${s.id}`:"dist",g=o?d.join(m,"plugins",o):m,r=[{name:"globalModules",setup:w=>{w.onResolve({filter:/^replugged(\/\w+)?$/},u=>{if(u.kind==="import-statement")return u.path.includes("dist")?{errors:[{text:`Unsupported import from dist: ${u.path}
Import from either the top level of this module ("replugged") or a top-level subpath (e.g. "replugged/common") instead.`}]}:{path:u.path,namespace:"replugged"}}),w.onResolve({filter:/^react$/},u=>{if(u.kind==="import-statement")return{path:"replugged/common/React",namespace:"replugged"}}),w.onLoad({filter:/.*/,namespace:"replugged"},u=>({contents:`module.exports = window.${u.path.replaceAll("/",".")}`}))}},{name:"install",setup:w=>{w.onEnd(async()=>{if(!t){let u=d.join(Ce,"plugins",s.id);O(u)&&le(u,{recursive:!0,force:!0}),je(a,u,{recursive:!0}),console.log("Installed updated version"),i||await de(s.id)}})}}];e&&r.push(oe);let y={absWorkingDir:m,bundle:!0,format:"esm",logLevel:"info",minify:n,platform:"browser",plugins:r,sourcemap:!n,target:`chrome${ke}`},P=[],v=await ce;"renderer"in s&&(P.push(z.context(v({...y,entryPoints:[d.join(g,s.renderer)],outfile:`${a}/renderer.js`}))),s.renderer="renderer.js"),"plaintextPatches"in s&&(P.push(z.context(v({...y,entryPoints:[d.join(g,s.plaintextPatches)],outfile:`${a}/plaintextPatches.js`}))),s.plaintextPatches="plaintextPatches.js"),O(a)||ae(a,{recursive:!0}),Ee(`${a}/manifest.json`,JSON.stringify(s));let x=await Promise.all(P);await Ne(x,e),l==null||l.close()}async function q({watch:e,noInstall:t,production:n,noReload:i,addon:o}){let p=o?d.join(m,"themes",o,"manifest.json"):"manifest.json",s=JSON.parse(X(p.toString(),"utf-8")),a=o?`dist/${s.id}`:"dist",g=o?d.join(m,"themes",o):m,c=d.join(g,s.main||"src/main.css"),f=O(d.join(g,s.splash||"src/main.css"))?d.join(g,s.splash||"src/main.css"):void 0,r={name:"install",setup:u=>{u.onEnd(async()=>{if(!t){let D=d.join(Ce,"themes",s.id);O(D)&&le(D,{recursive:!0,force:!0}),je(a,D,{recursive:!0}),console.log("Installed updated version"),i||await de(s.id)}})}},y=[He(),r];e&&y.push(oe);let P={absWorkingDir:m,bundle:!0,format:"esm",logLevel:"info",minify:n,platform:"browser",plugins:y,sourcemap:!n,target:`chrome${ke}`},v=[],x=await ce;c&&(v.push(z.context(x({...P,entryPoints:[c],outfile:`${a}/main.css`}))),s.main="main.css"),f&&(v.push(z.context(x({...P,entryPoints:[f],outfile:`${a}/splash.css`}))),s.plaintextPatches="splash.css"),O(a)||ae(a,{recursive:!0}),Ee(`${a}/manifest.json`,JSON.stringify(s));let w=await Promise.all(v);await Ne(w,e),l==null||l.close()}var{argv:It}=We(Ve(process.argv)).scriptName("replugged").usage("$0 <cmd> [args]").command("build <addon>","Build an Addon",e=>{e.positional("addon",{type:"string",describe:"Either a plugin or theme"}),e.option("no-install",{type:"boolean",describe:"Don't install the built addon",default:!1}),e.option("watch",{type:"boolean",describe:"Watch the addon for changes to reload building",default:!1}),e.option("production",{type:"boolean",describe:"Don't compile the source maps when building.",default:!1}),e.option("no-reload",{type:"boolean",describe:"Don't reload the addon in Discord after building.",default:!1}),e.option("all",{type:"boolean",describe:"Build all addons in a monorepo.",default:!1})},async e=>{if(e.addon==="plugin"){if(e.all&&h)return $e(H,e,"plugins");{let t=h?await N("plugins"):void 0;H({...e,addon:t==null?void 0:t.name})}}else if(e.addon==="theme"){if(e.all&&h)return $e(q,e,"themes");{let t=h?await N("themes"):void 0;q({...e,addon:t==null?void 0:t.name})}}else console.log("Invalid addon type.");Pe()}).command("bundle <addon>","Bundle any Addon",e=>{e.positional("addon",{type:"string",describe:"Either a plugin or theme"})},async e=>{if(e.addon==="plugin"){if(e.all&&h)return Ae(H,"plugins");{let t=h?await N("plugins"):void 0;re(H,t==null?void 0:t.name,"plugins")}}else if(e.addon==="theme"){if(e.all&&h)return Ae(q,"themes");{let t=h?await N("themes"):void 0;re(q,t==null?void 0:t.name,"themes")}}else console.log("Invalid addon type.");Pe()}).command("release","Interactively release a new version of an addon",()=>{},be).parserConfiguration({"boolean-negation":!1}).help();export{m as directory};
